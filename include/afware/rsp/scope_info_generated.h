// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SCOPEINFO_RSP_H_
#define FLATBUFFERS_GENERATED_SCOPEINFO_RSP_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 && FLATBUFFERS_VERSION_MINOR == 9 && FLATBUFFERS_VERSION_REVISION == 23,
              "Non-compatible flatbuffers version included");

namespace RSP {

struct MetadataEntry;
struct MetadataEntryBuilder;

struct ScopeInfo;
struct ScopeInfoBuilder;

enum MetadataType : int8_t {
  MetadataType_UNSET  = 0,
  MetadataType_INT8   = 1,
  MetadataType_UINT8  = 2,
  MetadataType_INT16  = 3,
  MetadataType_UINT16 = 4,
  MetadataType_INT32  = 5,
  MetadataType_UINT32 = 6,
  MetadataType_INT64  = 7,
  MetadataType_UINT64 = 8,
  MetadataType_FLOAT  = 9,
  MetadataType_DOUBLE = 10,
  MetadataType_MIN    = MetadataType_UNSET,
  MetadataType_MAX    = MetadataType_DOUBLE
};

inline const MetadataType (&EnumValuesMetadataType())[11] {
  static const MetadataType values[] = {MetadataType_UNSET,
                                        MetadataType_INT8,
                                        MetadataType_UINT8,
                                        MetadataType_INT16,
                                        MetadataType_UINT16,
                                        MetadataType_INT32,
                                        MetadataType_UINT32,
                                        MetadataType_INT64,
                                        MetadataType_UINT64,
                                        MetadataType_FLOAT,
                                        MetadataType_DOUBLE};
  return values;
}

inline const char *const *EnumNamesMetadataType() {
  static const char *const names[12] = {
      "UNSET", "INT8", "UINT8", "INT16", "UINT16", "INT32", "UINT32", "INT64", "UINT64", "FLOAT", "DOUBLE", nullptr};
  return names;
}

inline const char *EnumNameMetadataType(MetadataType e) {
  if (::flatbuffers::IsOutRange(e, MetadataType_UNSET, MetadataType_DOUBLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMetadataType()[index];
}

struct MetadataEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetadataEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TAG = 4, VT_TYPE = 6, VT_VALUE = 8 };
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  RSP::MetadataType type() const {
    return static_cast<RSP::MetadataType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TAG) && verifier.VerifyString(tag()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) && VerifyField<uint64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct MetadataEntryBuilder {
  typedef MetadataEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(MetadataEntry::VT_TAG, tag);
  }
  void add_type(RSP::MetadataType type) {
    fbb_.AddElement<int8_t>(MetadataEntry::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(MetadataEntry::VT_VALUE, value, 0);
  }
  explicit MetadataEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MetadataEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o         = ::flatbuffers::Offset<MetadataEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MetadataEntry> CreateMetadataEntry(::flatbuffers::FlatBufferBuilder &_fbb,
                                                                ::flatbuffers::Offset<::flatbuffers::String> tag = 0,
                                                                RSP::MetadataType type = RSP::MetadataType_UNSET,
                                                                uint64_t value         = 0) {
  MetadataEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_tag(tag);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MetadataEntry> CreateMetadataEntryDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                                                                      const char *tag        = nullptr,
                                                                      RSP::MetadataType type = RSP::MetadataType_UNSET,
                                                                      uint64_t value         = 0) {
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  return RSP::CreateMetadataEntry(_fbb, tag__, type, value);
}

struct ScopeInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScopeInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TAG                     = 4,
    VT_TICKS_START             = 6,
    VT_TICKS_END               = 8,
    VT_MACHINE_NOMINAL_FREQ_HZ = 10,
    VT_MAX_BUFFER_SIZE         = 12,
    VT_MAX_OFFSET              = 14,
    VT_METADATA                = 16
  };
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  uint64_t ticks_start() const {
    return GetField<uint64_t>(VT_TICKS_START, 0);
  }
  uint64_t ticks_end() const {
    return GetField<uint64_t>(VT_TICKS_END, 0);
  }
  uint64_t machine_nominal_freq_hz() const {
    return GetField<uint64_t>(VT_MACHINE_NOMINAL_FREQ_HZ, 0);
  }
  uint64_t max_buffer_size() const {
    return GetField<uint64_t>(VT_MAX_BUFFER_SIZE, 0);
  }
  uint8_t max_offset() const {
    return GetField<uint8_t>(VT_MAX_OFFSET, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<RSP::MetadataEntry>> *metadata() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<RSP::MetadataEntry>> *>(VT_METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TAG) && verifier.VerifyString(tag()) &&
           VerifyField<uint64_t>(verifier, VT_TICKS_START, 8) && VerifyField<uint64_t>(verifier, VT_TICKS_END, 8) &&
           VerifyField<uint64_t>(verifier, VT_MACHINE_NOMINAL_FREQ_HZ, 8) &&
           VerifyField<uint64_t>(verifier, VT_MAX_BUFFER_SIZE, 8) && VerifyField<uint8_t>(verifier, VT_MAX_OFFSET, 1) &&
           VerifyOffset(verifier, VT_METADATA) && verifier.VerifyVector(metadata()) &&
           verifier.VerifyVectorOfTables(metadata()) && verifier.EndTable();
  }
};

struct ScopeInfoBuilder {
  typedef ScopeInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(ScopeInfo::VT_TAG, tag);
  }
  void add_ticks_start(uint64_t ticks_start) {
    fbb_.AddElement<uint64_t>(ScopeInfo::VT_TICKS_START, ticks_start, 0);
  }
  void add_ticks_end(uint64_t ticks_end) {
    fbb_.AddElement<uint64_t>(ScopeInfo::VT_TICKS_END, ticks_end, 0);
  }
  void add_machine_nominal_freq_hz(uint64_t machine_nominal_freq_hz) {
    fbb_.AddElement<uint64_t>(ScopeInfo::VT_MACHINE_NOMINAL_FREQ_HZ, machine_nominal_freq_hz, 0);
  }
  void add_max_buffer_size(uint64_t max_buffer_size) {
    fbb_.AddElement<uint64_t>(ScopeInfo::VT_MAX_BUFFER_SIZE, max_buffer_size, 0);
  }
  void add_max_offset(uint8_t max_offset) {
    fbb_.AddElement<uint8_t>(ScopeInfo::VT_MAX_OFFSET, max_offset, 0);
  }
  void add_metadata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<RSP::MetadataEntry>>> metadata) {
    fbb_.AddOffset(ScopeInfo::VT_METADATA, metadata);
  }
  explicit ScopeInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScopeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o         = ::flatbuffers::Offset<ScopeInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScopeInfo> CreateScopeInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> tag                                                 = 0,
    uint64_t ticks_start                                                                             = 0,
    uint64_t ticks_end                                                                               = 0,
    uint64_t machine_nominal_freq_hz                                                                 = 0,
    uint64_t max_buffer_size                                                                         = 0,
    uint8_t max_offset                                                                               = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<RSP::MetadataEntry>>> metadata = 0) {
  ScopeInfoBuilder builder_(_fbb);
  builder_.add_max_buffer_size(max_buffer_size);
  builder_.add_machine_nominal_freq_hz(machine_nominal_freq_hz);
  builder_.add_ticks_end(ticks_end);
  builder_.add_ticks_start(ticks_start);
  builder_.add_metadata(metadata);
  builder_.add_tag(tag);
  builder_.add_max_offset(max_offset);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ScopeInfo> CreateScopeInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *tag                                                        = nullptr,
    uint64_t ticks_start                                                   = 0,
    uint64_t ticks_end                                                     = 0,
    uint64_t machine_nominal_freq_hz                                       = 0,
    uint64_t max_buffer_size                                               = 0,
    uint8_t max_offset                                                     = 0,
    const std::vector<::flatbuffers::Offset<RSP::MetadataEntry>> *metadata = nullptr) {
  auto tag__      = tag ? _fbb.CreateString(tag) : 0;
  auto metadata__ = metadata ? _fbb.CreateVector<::flatbuffers::Offset<RSP::MetadataEntry>>(*metadata) : 0;
  return RSP::CreateScopeInfo(
      _fbb, tag__, ticks_start, ticks_end, machine_nominal_freq_hz, max_buffer_size, max_offset, metadata__);
}

inline const RSP::ScopeInfo *GetScopeInfo(const void *buf) {
  return ::flatbuffers::GetRoot<RSP::ScopeInfo>(buf);
}

inline const RSP::ScopeInfo *GetSizePrefixedScopeInfo(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<RSP::ScopeInfo>(buf);
}

inline bool VerifyScopeInfoBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<RSP::ScopeInfo>(nullptr);
}

inline bool VerifySizePrefixedScopeInfoBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<RSP::ScopeInfo>(nullptr);
}

inline void FinishScopeInfoBuffer(::flatbuffers::FlatBufferBuilder &fbb, ::flatbuffers::Offset<RSP::ScopeInfo> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedScopeInfoBuffer(::flatbuffers::FlatBufferBuilder &fbb,
                                              ::flatbuffers::Offset<RSP::ScopeInfo> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace RSP

#endif  // FLATBUFFERS_GENERATED_SCOPEINFO_RSP_H_
